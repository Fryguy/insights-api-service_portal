=begin
Insights Service Catalog API

This is a API to fetch and order catalog items from different cloud sources

OpenAPI spec version: 1.0.0
Contact: you@your-company.com
Generated by: https://github.com/swagger-api/swagger-codegen.git

=end


class OrderItem < ApplicationRecord
  validates_presence_of :count
  validates_presence_of :parameters

  belongs_to :order
  has_many :progress_messages
  after_initialize :set_defaults, unless: :persisted?

  serialize :parameters, Array
  NON_DATE_ATTRIBUTES = %w(order_id catalog_id plan_id provider_id state parameters )
  DATE_ATTRIBUTES     = %w(created_at ordered_at completed_at updated_at)

  def to_hash
    attributes.slice(*NON_DATE_ATTRIBUTES).tap do |hash|
      DATE_ATTRIBUTES.each do |attr| 
        hash[attr] = self.send(attr.to_sym).iso8601 if self.send(attr.to_sym)
      end
    end.merge(:id => id.to_s)
  end

  def submit
    self.state = 'Ordered'
    self.ordered_at = DateTime.now
    prov = Provider.find(provider_id)
    self.external_ref = prov.order_catalog(catalog_id, plan_id, parameters)
    save!
    Thread.new { monitor }
  end

  def set_defaults
    self.state = "Created"
  end

  def update_message(level, message)
    self.updated_at = DateTime.now
    ProgressMessage.create(:level         => level,
                           :message       => message,
                           :order_item_id => id)
  end

  def monitor
    prov = Provider.find(provider_id)
    reason = "Provisioning"
    inflight = %w(Provisioning ProvisionRequestInFlight)
    parsed_data = {}
    while inflight.include?(reason) do
      sleep(5)
      response = prov.service_status(external_ref)
      parsed_data = JSON.parse(response.body)
      async = parsed_data['status']['asyncOpInProgress']

      message = parsed_data['status']['conditions'][0]['message']
      # puts "Status : #{parsed_data['status']['conditions'][0]['status']}"
      # puts "Type : #{parsed_data['status']['conditions'][0]['type']}"
      reason = parsed_data['status']['conditions'][0]['reason']
      level = reason == 'ProvisionCallFailed' ? 'error' : 'info'
      update_message(level, message)
    end
    set_final_state(reason)
    order.finalize_order
  end

  def set_final_state(reason)
    case reason
    when "ProvisionCallFailed"
      mark_failed
    when "ProvisionedSuccessfully"
      mark_finished
    else
      mark_finished
    end
  end

  def mark_failed
    self.completed_at = DateTime.now
    self.state = 'Failed'
    save!
  end

  def mark_finished
    self.completed_at = DateTime.now
    self.state = 'Completed'
    save!
  end
end
